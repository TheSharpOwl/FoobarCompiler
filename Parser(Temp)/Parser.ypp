
%require "3.2"
%language "C++"
%define api.value.type variant
%define api.token.constructor
%define parse.assert

%code requires
{
    #include <iostream>
    #include <string>

    // forward decleration
    namespace yy
    {
        class parser;
    }
}

%code
{
    namespace yy
    {
        parser::symbol_type yylex();
        // no need to override the error function because it is already waiting for our implementation
    }
}

/* declare tokens */
%token IDENTIFIER
%token INTEGER REAL
%token ADD SUB MUL DIV MOD
%token GRT GRTE LES LESE EQ NEQ
%token AND OR XOR
%token IF THEN ELSE
%token TRU FLS
%token VAR COL
%token TKEY
%token RUT
%token LBR RBR
%token COM
%token RTN IS
%token RNG IN REV
%token FOR WHL LOP
%token END
%token RCRD
%token ARY LAR RAR
%token DOTN
%token ASN
%token ITYPE RTYPE BTYPE
%token EOL



%type <std::string> type PrimitiveType IDENTIFIER RecordType ArrayType
%type <std::string> Expression Primary ModifiablePrimary RoutineCall
%type <double> REAL
%type <int> INTEGER

%left OR
%left XOR
%left AND
%left EQ NEQ
%left GRT GRTE LES LESE
%left ADD SUB
%left MUL DIV MOD


%%
program:
| program EOL
| program SimpleDeclaration {  }
| program RoutineDeclaration
;

SimpleDeclaration: VariableDeclaration
| TypeDeclaration
;

VariableDeclaration: VAR IDENTIFIER COL type { std::cout << "hmmm\n"; std::cout << "defined variable " << ($2) << "with type" << ($4); }
| VAR IDENTIFIER IS Expression
| VAR IDENTIFIER COL type IS Expression
;

TypeDeclaration: TKEY IDENTIFIER IS type { std::cout << "defined new type " << ($2) << "\n"; }
;

RoutineDeclaration: RUT IDENTIFIER LBR Parameters RBR IS Body END { std::cout << "routine " << ($2) << "was declared\n"; }
| RUT IDENTIFIER LBR Parameters RBR COL type IS Body END {  std::cout << "routine " << ($2) << "was declared\n";  }
;

Parameters: ParameterDeclaration
| Parameters COM ParameterDeclaration
;

ParameterDeclaration: IDENTIFIER COL type
;

type: IDENTIFIER
| PrimitiveType
| ArrayType
| RecordType
;

PrimitiveType: ITYPE { ($$) =  "int"; }
| RTYPE {              ($$) =  "real"; }
| BTYPE {              ($$) =  "bool"; }
;

RecordType: RCRD VariableDeclarationBlock END {  ($$) =  "record"; std::cout << "record was defined\n"; }
;

ArrayType: ARY LAR Expression RAR type {    ($$) = "array"; std::cout <<"array was defined\n"; }
| ARY LAR RAR type {                        ($$) = "array"; std::cout << "array was defined\n"; }
;

Body:
| Body SimpleDeclaration
| Body Statement
| Body EOL
;

Statement: Assignment
| RoutineCall
| WhileLoop
| ForLoop
| IfStatement
| Returntatement {std::cout << "return\n";}
;

Returntatement: RTN EOL
| RTN Expression
;

Assignment: ModifiablePrimary ASN Expression
;

RoutineCall: IDENTIFIER LBR Arguments RBR { std::cout << "routine " << ($1) << " was called\n"; }
;

WhileLoop: WHL Expression LOP Body END { std::cout << "while loop\n"; }
;

ForLoop: FOR IDENTIFIER Range LOP Body END { std::cout << "for loop\n"; }
;

Range: IN Expression RNG Expression
| IN REV Expression RNG Expression
;

IfStatement: IF Expression THEN Body END
| IF Expression THEN Body EOL ELSE Body END
;

VariableDeclarationBlock:
| VariableDeclarationBlock VariableDeclaration
| VariableDeclarationBlock EOL
;

Expression: Expression ADD Expression { $$ = ($1) + "+" + ($3);  std::cout << ($$) << "\n";}
| Expression SUB Expression  {          $$ = ($1) + "-" + ($3);  std::cout << ($$) << "\n";}
| Expression DIV Expression {           $$ = ($1) + "/" + ($3);  std::cout << ($$) << "\n";}
| Expression MUL Expression {           $$ = ($1) + "*" + ($3);  std::cout << ($$) << "\n";}
| Expression MOD Expression {           $$ = ($1) + "%" + ($3);  std::cout << ($$) << "\n";}
| Expression GRT Expression {           $$ = ($1) + ">" + ($3);  std::cout << ($$) << "\n";}
| Expression GRTE Expression {          $$ = ($1) + ">=" + ($3); std::cout << ($$) << "\n";}
| Expression LES Expression {           $$ = ($1) + "<" + ($3);  std::cout << ($$) << "\n";}
| Expression LESE Expression {          $$ = ($1) + "<=" + ($3); std::cout << ($$) << "\n";}
| Expression EQ Expression {            $$ = ($1) + "=" + ($3);  std::cout << ($$) << "\n";}
| Expression NEQ Expression {           $$ = ($1) + "/=" + ($3); std::cout << ($$) << "\n";}
| Expression AND Expression {           $$ = ($1) + "and" + ($3);std::cout << ($$) << "\n";}
| Expression OR Expression {            $$ = ($1) + "or" + ($3); std::cout << ($$) << "\n";}
| Expression XOR Expression {           $$ = ($1) + "xor" + ($3);std::cout << ($$) << "\n";}
| SUB Expression { ($$) = ($2);                                 std::cout << "unary minus\n"; }
| Primary {  }
| LBR Expression RBR { ($$) = ($2); std::cout  << "braces around" << ($$) << "\n"; }
;

Arguments: Expression
| Arguments COM Expression
;

Primary: INTEGER {      $$ = "integer"; }
| REAL {                $$ = "real"; }
| TRU {                 $$ = "true";}
| FLS {                 $$ = "false"; }
| ModifiablePrimary{    $$ = "modifiablePrimary"; }
| RoutineCall {         $$ = "routineCall"; }
;

VariableAcess:
| VariableAcess DOTN IDENTIFIER
| VariableAcess LAR Expression RAR
;

ModifiablePrimary: IDENTIFIER VariableAcess
;
%%
namespace yy
{
    parser::symbol_type yylex()
    {
        return 0;
    }

    void parser::error(const std::string& msg)
    {
        std::cout<<"syntax error!\n";
    }
}