
%require "3.2"
%define api.pure full


%code{
#pragma once
#include <iostream>
#include<stdio.h>
#include "Scanner.h"
}



%code{
    int yylex(YYSTYPE *lvalp);
    #include<iostream>
    #include<string>
    Scanner scanner;
    void yyerror(const char *error);
}


%union {
int n;
double d;
char s[1025];
}


/* declare tokens */
%token IDENTIFIER
%token INTEGER REAL
%token ADD SUB MUL DIV MOD
%token GRT GRTE LES LESE EQ NEQ
%token AND OR XOR
%token IF THEN ELSE
%token TRU FLS
%token VAR COL
%token TKEY
%token RUT
%token LBR RBR
%token COM
%token RTN IS
%token RNG IN REV
%token FOR WHL LOP
%token END
%token RCRD
%token ARY LAR RAR
%token DOTN
%token ASN
%token ITYPE RTYPE BTYPE
%token EOL



%type <s> type PrimitiveType IDENTIFIER RecordType ArrayType
%type <s> Expression Primary INTEGER REAL TRU FLS ModifiablePrimary RoutineCall

%left OR
%left XOR
%left AND
%left EQ NEQ
%left GRT GRTE LES LESE
%left ADD SUB
%left MUL DIV MOD


%%
program:
| program EOL
| program SimpleDeclaration {  }
| program RoutineDeclaration
;

SimpleDeclaration: VariableDeclaration
| TypeDeclaration
;

VariableDeclaration: VAR IDENTIFIER COL type { std::cout << "defined variable " << $2 << "with type" << $4; }
| VAR IDENTIFIER IS Expression
| VAR IDENTIFIER COL type IS Expression
;

TypeDeclaration: TKEY IDENTIFIER IS type { std::cout << "defined new type " << $2 << "\n"; }
;

RoutineDeclaration: RUT IDENTIFIER LBR Parameters RBR IS Body END { std::cout << "routine " << $2 << "was declared\n"; }
| RUT IDENTIFIER LBR Parameters RBR COL type IS Body END {  std::cout << "routine " << $2 << "was declared\n";  }
;

Parameters: ParameterDeclaration
| Parameters COM ParameterDeclaration
;

ParameterDeclaration: IDENTIFIER COL type
;

type: IDENTIFIER
| PrimitiveType
| ArrayType
| RecordType
;

PrimitiveType: ITYPE { /*strcpy($$, "int"); */}
| RTYPE {              /*strcpy($$, "real");*/ }
| BTYPE {              /*strcpy($$, "bool");*/ }
;

RecordType: RCRD VariableDeclarationBlock END {  /*strcpy($$, "record");*/ std::cout << "record was defined\n"; }
;

ArrayType: ARY LAR Expression RAR type {  /*strcpy($$, "array");*/ std::cout <<"array was defined\n"; }
| ARY LAR RAR type {  /*strcpy($$, "array");*/ std::cout << "array was defined\n"; }
;

Body:
| Body SimpleDeclaration
| Body Statement
| Body EOL
;

Statement: Assignment
| RoutineCall
| WhileLoop
| ForLoop
| IfStatement
| Returntatement {std::cout << "return\n";}
;

Returntatement: RTN EOL
| RTN Expression
;

Assignment: ModifiablePrimary ASN Expression
;

RoutineCall: IDENTIFIER LBR Arguments RBR { std::cout << "routine " << $1 << " was called\n"; }
;

WhileLoop: WHL Expression LOP Body END { std::cout << "while loop\n"; }
;

ForLoop: FOR IDENTIFIER Range LOP Body END { std::cout << "for loop\n"; }
;

Range: IN Expression RNG Expression
| IN REV Expression RNG Expression
;

IfStatement: IF Expression THEN Body END
| IF Expression THEN Body EOL ELSE Body END
;

VariableDeclarationBlock:
| VariableDeclarationBlock VariableDeclaration
| VariableDeclarationBlock EOL
;

Expression: Expression ADD Expression { sprintf($$, "[%s+%s]", $1, $3); std::cout << $1 << "+" << $3 << "\n"; }
| Expression SUB Expression  { sprintf($$, "[%s-%s]", $1, $3);          std::cout << $1 << "-" << $3 << "\n"; }
| Expression DIV Expression { sprintf($$, "[%s/%s]", $1, $3);           std::cout << $1 << "/" << $3 << "\n"; }
| Expression MUL Expression { sprintf($$, "[%s*%s]", $1, $3);           std::cout << $1 << "*" << $3 << "\n"; }
| Expression MOD Expression { sprintf($$, "[%s%%%s]", $1, $3);          std::cout << $1 << "%" << $3 << "\n"; }
| Expression GRT Expression { sprintf($$, "[%s>%s]", $1, $3);           std::cout << $1 << ">" << $3 << "\n"; }
| Expression GRTE Expression { sprintf($$, "[%s>=%s]", $1, $3);         std::cout << $1 << ">=" << $3 << "\n"; }
| Expression LES Expression { sprintf($$, "[%s<%s]", $1, $3);           std::cout << $1 << "<" << $3 << "\n"; }
| Expression LESE Expression { sprintf($$, "[%s<=%s]", $1, $3);         std::cout << $1 << "<=" << $3 << "\n"; }
| Expression EQ Expression { sprintf($$, "[%s=%s]", $1, $3);            std::cout << $1 << "=" << $3 << "\n"; }
| Expression NEQ Expression { sprintf($$, "[%s/=%s]", $1, $3);          std::cout << $1 << "/=" << $3 << "\n"; }
| Expression AND Expression { sprintf($$, "[%s and %s]", $1, $3);       std::cout << $1 << "and" << $3 <<"\n";}
| Expression OR Expression { sprintf($$, "[%s or %s]", $1, $3);         std::cout << $1 << "or" << $3 <<"\n";}
| Expression XOR Expression { sprintf($$, "[%s xor %s]", $1, $3);       std::cout << $1 << "xor" << $3 <<"\n";}
| SUB Expression { /*strcpy($$, $2);*/                                  std::cout << "unary minus\n"; }
| Primary {  }
| LBR Expression RBR { /*strcpy($$, $2);*/ std::cout  << "braces around" << $2 << "\n"; }
;

Arguments: Expression
| Arguments COM Expression
;

Primary: INTEGER { /*strcpy($$, "integer");*/ }
| REAL { /*strcpy($$, "real");*/ }
| TRU { /*strcpy($$, "true"); */}
| FLS { /*strcpy($$, "false");*/ }
| ModifiablePrimary { /*strcpy($$, "modifiablePrimary");*/ }
| RoutineCall { /*strcpy($$, "routineCall");*/ }
;

VariableAcess:
| VariableAcess DOTN IDENTIFIER
| VariableAcess LAR Expression RAR
;

ModifiablePrimary: IDENTIFIER VariableAcess
;
%%
int main()
{
    scanner.set_file("inp.txt");
    return yyparse();
}

void yyerror(const char *error)
{
    std::cout << "syntax error" << std::endl;
}

int yylex(YYSTYPE *lvalp)
{
	return scanner.get_next_token(lvalp);
}