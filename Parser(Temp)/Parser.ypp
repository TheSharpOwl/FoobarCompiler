%require "3.2"
%language "c++"
%define api.value.type variant
//%define api.pure full

%{
#include<string>
#include<iostream>
#include "Scanner.h"
#include <stdio.h>
%}

%code{
#include <string.h>
}



%code{
    //int yylex(YYSTYPE *lvalp);
    
    Scanner scanner;
    void yyerror(const char *error);
}


/* declare tokens */
%token IDENTIFIER
%token INTEGER REAL
%token ADD SUB MUL DIV MOD
%token GRT GRTE LES LESE EQ NEQ
%token AND OR XOR
%token IF THEN ELSE
%token TRU FLS
%token VAR COL
%token TKEY
%token RUT
%token LBR RBR
%token COM
%token RTN IS
%token RNG IN REV
%token FOR WHL LOP
%token END
%token RCRD
%token ARY LAR RAR
%token DOTN
%token ASN
%token ITYPE RTYPE BTYPE
%token EOL



%type <std::string> type PrimitiveType IDENTIFIER RecordType ArrayType
%type <std::string> Expression Primary INTEGER REAL TRU FLS ModifiablePrimary RoutineCall

%left OR
%left XOR
%left AND
%left EQ NEQ
%left GRT GRTE LES LESE
%left ADD SUB
%left MUL DIV MOD


%%
program:
| program EOL
| program SimpleDeclaration {  }
| program RoutineDeclaration
;

SimpleDeclaration: VariableDeclaration
| TypeDeclaration
;

VariableDeclaration: VAR IDENTIFIER COL type { printf("defined variable \"%s\" with type %s\n", $2.c_str(), $4.c_str()); }
| VAR IDENTIFIER IS Expression
| VAR IDENTIFIER COL type IS Expression
;

TypeDeclaration: TKEY IDENTIFIER IS type { printf("defined new type %s \n", $2.c_str()); }
;

RoutineDeclaration: RUT IDENTIFIER LBR Parameters RBR IS Body END { printf("routine %s was declared\n", $2.c_str()); }
| RUT IDENTIFIER LBR Parameters RBR COL type IS Body END { printf("routine %s was declared\n", $2.c_str()); }
;

Parameters: ParameterDeclaration
| Parameters COM ParameterDeclaration
;

ParameterDeclaration: IDENTIFIER COL type
;

type: IDENTIFIER
| PrimitiveType
| ArrayType
| RecordType
;

PrimitiveType: ITYPE { $$ = "int"; }
| RTYPE { $$ = "real"; }
| BTYPE { $$ = "bool"; }
;

RecordType: RCRD VariableDeclarationBlock END {   $$ = "record"; printf("record was defined\n"); }
;

ArrayType: ARY LAR Expression RAR type {  $$ = "array"; printf("array was defined\n"); }
| ARY LAR RAR type {  $$ = "array"; printf("array was defined\n"); }
;

Body:
| Body SimpleDeclaration
| Body Statement
| Body EOL
;

Statement: Assignment
| RoutineCall
| WhileLoop
| ForLoop
| IfStatement
| Returntatement { printf("return\n"); }
;

Returntatement: RTN EOL
| RTN Expression
;

Assignment: ModifiablePrimary ASN Expression
;

RoutineCall: IDENTIFIER LBR Arguments RBR { printf("routine %s was called\n", $1.c_str()); }
;

WhileLoop: WHL Expression LOP Body END { printf("while loop\n"); }
;

ForLoop: FOR IDENTIFIER Range LOP Body END { printf("for loop\n"); }
;

Range: IN Expression RNG Expression
| IN REV Expression RNG Expression
;

IfStatement: IF Expression THEN Body END
| IF Expression THEN Body EOL ELSE Body END
;

VariableDeclarationBlock:
| VariableDeclarationBlock VariableDeclaration
| VariableDeclarationBlock EOL
;

Expression: Expression ADD Expression { $$ = $1 + "+"   + $3; printf("%s+%s\n", $1.c_str(), $3.c_str()); }
| Expression SUB Expression  {          $$ = $1 + "-"   + $3; printf("%s-%s\n", $1.c_str(), $3.c_str()); }
| Expression DIV Expression {           $$ = $1 + "/"   + $3; printf("%s/%s\n", $1.c_str(), $3.c_str()); }
| Expression MUL Expression {           $$ = $1 + "*"   + $3; printf("%s*%s\n", $1.c_str(), $3.c_str()); }
| Expression MOD Expression {           $$ = $1 + "%"   + $3;  printf("%s%%%s\n", $1.c_str(), $3.c_str()); }
| Expression GRT Expression {           $$ = $1 + ">"   + $3; printf("%s>%s\n", $1.c_str(), $3.c_str()); }
| Expression GRTE Expression {          $$ = $1 + ">="  + $3;  printf("%s>=%s\n", $1.c_str(), $3.c_str()); }
| Expression LES Expression {           $$ = $1 + "<"   + $3; printf("%s<%s\n", $1.c_str(), $3.c_str()); }
| Expression LESE Expression {          $$ = $1 + "<="  + $3;  printf("%s<=>%s\n", $1.c_str(), $3.c_str()); }
| Expression EQ Expression {            $$ = $1 + "="   + $3; printf("%s=%s\n", $1.c_str(), $3.c_str()); }
| Expression NEQ Expression {           $$ = $1 + "/="  + $3;  printf("%s/=%s\n", $1.c_str(), $3.c_str()); }
| Expression AND Expression {           $$ = $1 + "and" + $3;  printf("%s and %s\n", $1.c_str(), $3.c_str()); }
| Expression OR Expression {            $$ = $1 + "or"  + $3; printf("%s or %s\n", $1.c_str(), $3.c_str()); }
| Expression XOR Expression {           $$ = $1 + "xor" + $3;   printf("%s xor %s\n", $1.c_str(), $3.c_str()); }
| SUB Expression { $$ = $2;  printf("unary minus\n"); }
| Primary {  }
| LBR Expression RBR { $$ = $2; printf("braces around %s\n", $2.c_str()); }
;

Arguments: Expression
| Arguments COM Expression
;

Primary: INTEGER {      $$ = "integer"; }
| REAL {                $$ = "real"; }
| TRU {                 $$ = "true"; }
| FLS {                 $$ = "false"; }
| ModifiablePrimary {   $$ = "modifiablePrimary"; }
| RoutineCall {         $$ = "routineCall"; }
;

VariableAcess:
| VariableAcess DOTN IDENTIFIER
| VariableAcess LAR Expression RAR
;

ModifiablePrimary: IDENTIFIER VariableAcess
;
%%
int main()
{
    scanner.set_file("inp.txt");
    return parser::parse();
}

void yyerror(const char *error)
{
    std::cout << "syntax error" << std::endl;
}

/*int yylex(YYSTYPE *lvalp)
{
	return scanner.get_next_token(lvalp);
}*/