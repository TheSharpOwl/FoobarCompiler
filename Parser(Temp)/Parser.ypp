
%require "3.2"
%define api.pure full

%{
#include<string>
%}
%code{
#pragma once
#include <iostream>
#include<stdio.h>
#include "Scanner.h"

}



%code{
    int yylex(YYSTYPE *lvalp);
    #include<iostream>
    #include<string>
    Scanner scanner;
    void yyerror(const char *error);
}


%union {
int n;
double d;
std::string* s;
}


/* declare tokens */
%token IDENTIFIER
%token INTEGER REAL
%token ADD SUB MUL DIV MOD
%token GRT GRTE LES LESE EQ NEQ
%token AND OR XOR
%token IF THEN ELSE
%token TRU FLS
%token VAR COL
%token TKEY
%token RUT
%token LBR RBR
%token COM
%token RTN IS
%token RNG IN REV
%token FOR WHL LOP
%token END
%token RCRD
%token ARY LAR RAR
%token DOTN
%token ASN
%token ITYPE RTYPE BTYPE
%token EOL



%type <s> type PrimitiveType IDENTIFIER RecordType ArrayType
%type <s> Expression Primary INTEGER REAL TRU FLS ModifiablePrimary RoutineCall

%left OR
%left XOR
%left AND
%left EQ NEQ
%left GRT GRTE LES LESE
%left ADD SUB
%left MUL DIV MOD


%%
program:
| program EOL
| program SimpleDeclaration {  }
| program RoutineDeclaration
;

SimpleDeclaration: VariableDeclaration
| TypeDeclaration
;

VariableDeclaration: VAR IDENTIFIER COL type { std::cout << "hmmm\n"; std::cout << "defined variable " << ($2) << "with type" << ($4); }
| VAR IDENTIFIER IS Expression
| VAR IDENTIFIER COL type IS Expression
;

TypeDeclaration: TKEY IDENTIFIER IS type { std::cout << "defined new type " << *($2) << "\n"; }
;

RoutineDeclaration: RUT IDENTIFIER LBR Parameters RBR IS Body END { std::cout << "routine " << *($2) << "was declared\n"; }
| RUT IDENTIFIER LBR Parameters RBR COL type IS Body END {  std::cout << "routine " << *($2) << "was declared\n";  }
;

Parameters: ParameterDeclaration
| Parameters COM ParameterDeclaration
;

ParameterDeclaration: IDENTIFIER COL type
;

type: IDENTIFIER
| PrimitiveType
| ArrayType
| RecordType
;

PrimitiveType: ITYPE { *($$) =  "int"; }
| RTYPE {              *($$) =  "real"; }
| BTYPE {              *($$) =  "bool"; }
;

RecordType: RCRD VariableDeclarationBlock END {  *($$) =  "record"; std::cout << "record was defined\n"; }
;

ArrayType: ARY LAR Expression RAR type {    *($$) = "array"; std::cout <<"array was defined\n"; }
| ARY LAR RAR type {                        *($$) = "array"; std::cout << "array was defined\n"; }
;

Body:
| Body SimpleDeclaration
| Body Statement
| Body EOL
;

Statement: Assignment
| RoutineCall
| WhileLoop
| ForLoop
| IfStatement
| Returntatement {std::cout << "return\n";}
;

Returntatement: RTN EOL
| RTN Expression
;

Assignment: ModifiablePrimary ASN Expression
;

RoutineCall: IDENTIFIER LBR Arguments RBR { std::cout << "routine " << *($1) << " was called\n"; }
;

WhileLoop: WHL Expression LOP Body END { std::cout << "while loop\n"; }
;

ForLoop: FOR IDENTIFIER Range LOP Body END { std::cout << "for loop\n"; }
;

Range: IN Expression RNG Expression
| IN REV Expression RNG Expression
;

IfStatement: IF Expression THEN Body END
| IF Expression THEN Body EOL ELSE Body END
;

VariableDeclarationBlock:
| VariableDeclarationBlock VariableDeclaration
| VariableDeclarationBlock EOL
;

Expression: Expression ADD Expression { *$$ = *($1) + "+" + *($3);  std::cout << *($$) << "\n";}
| Expression SUB Expression  {          *$$ = *($1) + "-" + *($3);  std::cout << *($$) << "\n";}
| Expression DIV Expression {           *$$ = *($1) + "/" + *($3);  std::cout << *($$) << "\n";}
| Expression MUL Expression {           *$$ = *($1) + "*" + *($3);  std::cout << *($$) << "\n";}
| Expression MOD Expression {           *$$ = *($1) + "%" + *($3);  std::cout << *($$) << "\n";}
| Expression GRT Expression {           *$$ = *($1) + ">" + *($3);  std::cout << *($$) << "\n";}
| Expression GRTE Expression {          *$$ = *($1) + ">=" + *($3); std::cout << *($$) << "\n";}
| Expression LES Expression {           *$$ = *($1) + "<" + *($3);  std::cout << *($$) << "\n";}
| Expression LESE Expression {          *$$ = *($1) + "<=" + *($3); std::cout << *($$) << "\n";}
| Expression EQ Expression {            *$$ = *($1) + "=" + *($3);  std::cout << *($$) << "\n";}
| Expression NEQ Expression {           *$$ = *($1) + "/=" + *($3); std::cout << *($$) << "\n";}
| Expression AND Expression {           *$$ = *($1) + "and" + *($3);std::cout << *($$) << "\n";}
| Expression OR Expression {            *$$ = *($1) + "or" + *($3); std::cout << *($$) << "\n";}
| Expression XOR Expression {           *$$ = *($1) + "xor" + *($3);std::cout << *($$) << "\n";}
| SUB Expression { *($$) = *($2);                                 std::cout << "unary minus\n"; }
| Primary {  }
| LBR Expression RBR { *($$) = *($2); std::cout  << "braces around" << *($$) << "\n"; }
;

Arguments: Expression
| Arguments COM Expression
;

Primary: INTEGER {      *($$) = "integer"; }
| REAL {                *($$) = "real"; }
| TRU {                 *($$) = "true";}
| FLS {                 *($$) = "false"; }
| ModifiablePrimary{    *($$) = "modifiablePrimary"; }
| RoutineCall {         *($$) = "routineCall"; }
;

VariableAcess:
| VariableAcess DOTN IDENTIFIER
| VariableAcess LAR Expression RAR
;

ModifiablePrimary: IDENTIFIER VariableAcess
;
%%
int main()
{
    scanner.set_file("inp.txt");
    //std::cout << "let's go\n";
    return yyparse();
}

void yyerror(const char *error)
{
    std::cout << "syntax error" << std::endl;
}

int yylex(YYSTYPE *lvalp)
{
	return scanner.get_next_token(lvalp);
}