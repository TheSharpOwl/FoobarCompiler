%require "3.2"
%define api.pure full


%code{
#include <stdio.h>
#include <string.h>
#include "Scanner.h"
}



%code{
    int yylex(YYSTYPE *lvalp);
    #include<iostream>
    #include<string>
    Scanner scanner;
    void yyerror(const char *error);
}


%union {
int n;
double d;
string s;
}


/* declare tokens */
%token IDENTIFIER
%token INTEGER REAL
%token ADD SUB MUL DIV MOD
%token GRT GRTE LES LESE EQ NEQ
%token AND OR XOR
%token IF THEN ELSE
%token TRU FLS
%token VAR COL
%token TKEY
%token RUT
%token LBR RBR
%token COM
%token RTN IS
%token RNG IN REV
%token FOR WHL LOP
%token END
%token RCRD
%token ARY LAR RAR
%token DOTN
%token ASN
%token ITYPE RTYPE BTYPE
%token EOL



%type <s> type PrimitiveType IDENTIFIER RecordType ArrayType
%type <s> Expression Primary INTEGER REAL TRU FLS ModifiablePrimary RoutineCall

%left OR
%left XOR
%left AND
%left EQ NEQ
%left GRT GRTE LES LESE
%left ADD SUB
%left MUL DIV MOD


%%
program:
| program EOL
| program SimpleDeclaration {  }
| program RoutineDeclaration
;

SimpleDeclaration: VariableDeclaration
| TypeDeclaration
;

VariableDeclaration: VAR IDENTIFIER COL type { printf("defined variable \"%s\" with type %s\n", $2, $4); }
| VAR IDENTIFIER IS Expression
| VAR IDENTIFIER COL type IS Expression
;

TypeDeclaration: TKEY IDENTIFIER IS type { printf("defined new type %s \n", $2); }
;

RoutineDeclaration: RUT IDENTIFIER LBR Parameters RBR IS Body END { printf("routine %s was declared\n", $2); }
| RUT IDENTIFIER LBR Parameters RBR COL type IS Body END { printf("routine %s was declared\n", $2); }
;

Parameters: ParameterDeclaration
| Parameters COM ParameterDeclaration
;

ParameterDeclaration: IDENTIFIER COL type
;

type: IDENTIFIER
| PrimitiveType
| ArrayType
| RecordType
;

PrimitiveType: ITYPE { strcpy($$, "int"); }
| RTYPE { strcpy($$, "real"); }
| BTYPE { strcpy($$, "bool"); }
;

RecordType: RCRD VariableDeclarationBlock END {  strcpy($$, "record"); printf("record was defined\n"); }
;

ArrayType: ARY LAR Expression RAR type {  strcpy($$, "array"); printf("array was defined\n"); }
| ARY LAR RAR type {  strcpy($$, "array"); printf("array was defined\n"); }
;

Body:
| Body SimpleDeclaration
| Body Statement
| Body EOL
;

Statement: Assignment
| RoutineCall
| WhileLoop
| ForLoop
| IfStatement
| Returntatement { printf("return\n"); }
;

Returntatement: RTN EOL
| RTN Expression
;

Assignment: ModifiablePrimary ASN Expression
;

RoutineCall: IDENTIFIER LBR Arguments RBR { printf("routine %s was called\n", $1); }
;

WhileLoop: WHL Expression LOP Body END { printf("while loop\n"); }
;

ForLoop: FOR IDENTIFIER Range LOP Body END { printf("for loop\n"); }
;

Range: IN Expression RNG Expression
| IN REV Expression RNG Expression
;

IfStatement: IF Expression THEN Body END
| IF Expression THEN Body EOL ELSE Body END
;

VariableDeclarationBlock:
| VariableDeclarationBlock VariableDeclaration
| VariableDeclarationBlock EOL
;

Expression: Expression ADD Expression { sprintf($$, "[%s+%s]", $1, $3); printf("%s+%s\n", $1, $3); }
| Expression SUB Expression  { sprintf($$, "[%s-%s]", $1, $3); printf("%s-%s\n", $1, $3); }
| Expression DIV Expression { sprintf($$, "[%s/%s]", $1, $3); printf("%s/%s\n", $1, $3); }
| Expression MUL Expression { sprintf($$, "[%s*%s]", $1, $3); printf("%s*%s\n", $1, $3); }
| Expression MOD Expression { sprintf($$, "[%s%%%s]", $1, $3); printf("%s%%%s\n", $1, $3); }
| Expression GRT Expression { sprintf($$, "[%s>%s]", $1, $3); printf("%s>%s\n", $1, $3); }
| Expression GRTE Expression { sprintf($$, "[%s>=%s]", $1, $3); printf("%s>=%s\n", $1, $3); }
| Expression LES Expression { sprintf($$, "[%s<%s]", $1, $3); printf("%s<%s\n", $1, $3); }
| Expression LESE Expression { sprintf($$, "[%s<=%s]", $1, $3); printf("%s<=>%s\n", $1, $3); }
| Expression EQ Expression { sprintf($$, "[%s=%s]", $1, $3); printf("%s=%s\n", $1, $3); }
| Expression NEQ Expression { sprintf($$, "[%s/=%s]", $1, $3); printf("%s/=%s\n", $1, $3); }
| Expression AND Expression { sprintf($$, "[%s and %s]", $1, $3); printf("%s and %s\n", $1, $3); }
| Expression OR Expression { sprintf($$, "[%s or %s]", $1, $3); printf("%s or %s\n", $1, $3); }
| Expression XOR Expression { sprintf($$, "[%s xor %s]", $1, $3);  printf("%s xor %s\n", $1, $3); }
| SUB Expression { strcpy($$, $2);  printf("unary minus\n"); }
| Primary {  }
| LBR Expression RBR { strcpy($$, $2); printf("braces around %s\n", $2); }
;

Arguments: Expression
| Arguments COM Expression
;

Primary: INTEGER { strcpy($$, "integer"); }
| REAL { strcpy($$, "real"); }
| TRU { strcpy($$, "true"); }
| FLS { strcpy($$, "false"); }
| ModifiablePrimary { strcpy($$, "modifiablePrimary"); }
| RoutineCall { strcpy($$, "routineCall"); }
;

VariableAcess:
| VariableAcess DOTN IDENTIFIER
| VariableAcess LAR Expression RAR
;

ModifiablePrimary: IDENTIFIER VariableAcess
;
%%
int main()
{
    scanner.set_file("inp.txt");
    return yyparse();
}

void yyerror(const char *error)
{
    std::cout << "syntax error" << std::endl;
}

int yylex(YYSTYPE *lvalp)
{
	return scanner.get_next_token(lvalp);
}