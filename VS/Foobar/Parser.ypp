
%require "3.2"
%language "C++"
%define api.value.type variant
%define api.token.constructor
%define parse.assert

%code requires
{
    #include <iostream>
    #include <string>
    #include "AST.hpp"

    // forward decleration
    namespace yy
    {
        class parser;
    }
    template <typename T> using sp = std::shared_ptr<T>;

}

%code
{
    // Our program is defined here
    sp<ast::Program> ourProgram;
    
    namespace yy
    {
        parser::symbol_type yylex();
        // no need to override the error function because it is already waiting for our implementation
    }
    void showExpr(const std::string& first, const std::string& op, const std::string& second)
    {
        std::cout<< first << op << second <<"\n";
        std::cout << "I am inside\n";
    }

}

/* declare tokens */
%token IDENTIFIER
%token INTEGER REAL
%token ADD SUB MUL DIV MOD
%token GRT GRTE LES LESE EQ NEQ
%token AND OR XOR
%token IF THEN ELSE
%token TRU FLS
%token VAR COL
%token TKEY
%token RUT
%token LBR RBR
%token COM
%token RTN IS
%token RNG IN REV
%token FOR WHL LOP
%token END
%token RCRD
%token ARY LAR RAR
%token DOTN
%token ASN
%token ITYPE RTYPE BTYPE
%token EOL
%token temp // TODO delete



%type<sp<ast::Type> > temp // TODO delete
%type<sp<ast::Type> > type;
%type<sp<ast::BuiltinType> > PrimitiveType
%type<sp<ast::Array> > ArrayType;
%type<sp<ast::Record> > RecordType;


%type <std::string>  IDENTIFIER
%type <std::string> Expression Primary ModifiablePrimary RoutineCall
%type <double> REAL
%type <int> INTEGER

%left OR
%left XOR
%left AND
%left EQ NEQ
%left GRT GRTE LES LESE
%left ADD SUB
%left MUL DIV MOD


%%
program:  /*{ourProgram = std::make_shared<ast::Program>(); std::cout << "made a program\n"; }*/
| program SimpleDeclaration {/* TODO maybe use this to add the variables to our vars*/ }
| program RoutineDeclaration {/* TODO use this to add the pointers to our routines*/}
| program EOL
;

SimpleDeclaration: VariableDeclaration
| TypeDeclaration
;

VariableDeclaration: VAR IDENTIFIER COL type { std::cout << "defined variable " << $2 << " with type " << ($4)->name << "\n"; }
| VAR IDENTIFIER IS Expression {std::cout << $2 << " " << $4 << std::endl;}
| VAR IDENTIFIER COL type IS Expression {}
;

TypeDeclaration: TKEY IDENTIFIER IS type { std::cout << "defined new type " << $2 << "\n"; }
;

RoutineDeclaration: RUT IDENTIFIER LBR Parameters RBR IS Body END { std::cout << "routine " << $2 << " was declared\n"; }
| RUT IDENTIFIER LBR Parameters RBR COL type IS Body END {  std::cout << "routine " << $2 << " was declared\n";  }
;

Parameters: ParameterDeclaration
| Parameters COM ParameterDeclaration
;

ParameterDeclaration: IDENTIFIER COL type
;

type:
| PrimitiveType {$$ = $1; /* casting from derived to base !!*/}
| ArrayType {$$ = $1; /* casting from derived to base !!*/}
| RecordType {$$ = $1; /* casting from derived to base !!*/}
;

PrimitiveType: ITYPE { $$ = std::make_shared<ast::BuiltinType>("integer");}
| RTYPE {              $$ =  std::make_shared<ast::BuiltinType> ("real"); }
| BTYPE {              $$ =  std::make_shared<ast::BuiltinType> ("boolean"); }
;

RecordType: RCRD VariableDeclarationBlock END {  $$ =  std::make_shared<ast::Record>("Record"); }
;

ArrayType: ARY LAR Expression RAR type { $$ = std::make_shared<ast::Array>("Array");}
| ARY LAR RAR type {                     $$ = std::make_shared<ast::Array>("Array");}
;

Body:
| Body SimpleDeclaration
| Body Statement
| Body EOL
;

Statement: Assignment
| RoutineCall
| WhileLoop
| ForLoop
| IfStatement
| Returntatement {std::cout << "return\n";}
;

Returntatement: RTN EOL
| RTN Expression
;

Assignment: ModifiablePrimary ASN Expression
;

RoutineCall: IDENTIFIER LBR Arguments RBR { std::cout << "routine " << $1 << " was called\n"; }
;

WhileLoop: WHL Expression LOP Body END { std::cout << "while loop\n"; }
;

ForLoop: FOR IDENTIFIER Range LOP Body END { std::cout << "for loop\n"; }
;

Range: IN Expression RNG Expression
| IN REV Expression RNG Expression
;

IfStatement: IF Expression THEN Body END
| IF Expression THEN Body EOL ELSE Body END
;

VariableDeclarationBlock:
| VariableDeclarationBlock VariableDeclaration
| VariableDeclarationBlock EOL
;

Expression: Expression ADD Expression { $$ = $1 + "+" + $3;   showExpr($$,$1,$3);}
| Expression SUB Expression  {          $$ = $1 + "-" + $3;   showExpr($$,$1,$3);}
| Expression DIV Expression {           $$ = $1 + "/" + $3;   showExpr($$,$1,$3);}
| Expression MUL Expression {           $$ = $1 + "*" + $3;   showExpr($$,$1,$3);}
| Expression MOD Expression {           $$ = $1 + "%" + $3;   showExpr($$,$1,$3);}
| Expression GRT Expression {           $$ = $1 + ">" + $3;   showExpr($$,$1,$3);}
| Expression GRTE Expression {          $$ = $1 + ">=" + $3;  showExpr($$,$1,$3);}
| Expression LES Expression {           $$ = $1 + "<" + $3;   showExpr($$,$1,$3);}
| Expression LESE Expression {          $$ = $1 + "<=" + $3;  showExpr($$,$1,$3);}
| Expression EQ Expression {            $$ = $1 + "=" + $3;   showExpr($$,$1,$3);}
| Expression NEQ Expression {           $$ = $1 + "/=" + $3;  showExpr($$,$1,$3);}
| Expression AND Expression {           $$ = $1 + "and" + $3; showExpr($$,$1,$3);}
| Expression OR Expression {            $$ = $1 + "or" + $3;  showExpr($$,$1,$3);}
| Expression XOR Expression {           $$ = $1 + "xor" + $3; showExpr($$,$1,$3);}
| SUB Expression { $$ = $2;                                 std::cout << "unary minus\n"; }
| Primary { $$ = $1; }
| LBR Expression RBR { $$ = $2; std::cout  << "braces around " << $$ << "\n"; }
;

Arguments: Expression
| Arguments COM Expression
;

Primary: INTEGER {      $$ = "integer"; }
| REAL {                $$ = "real"; }
| TRU {                 $$ = "true";}
| FLS {                 $$ = "false"; }
| ModifiablePrimary{    $$ = "modifiablePrimary"; }
| RoutineCall {         $$ = "routineCall"; }
;

VariableAcess:
| VariableAcess DOTN IDENTIFIER
| VariableAcess LAR Expression RAR
;

ModifiablePrimary: IDENTIFIER VariableAcess
;
%%
namespace yy
{
    //overriding yylex in main.cpp

    void parser::error(const std::string& msg)
    {
        std::cout<<"syntax error!\n";
    }
}