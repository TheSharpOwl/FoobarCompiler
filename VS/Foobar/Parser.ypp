
%require "3.2"
%language "C++"
%define api.value.type variant
%define api.token.constructor
%define parse.assert

%code requires
{
    #include <iostream>
    #include <string>
    #include "AST.hpp"

    // forward decleration
    namespace yy
    {
        class parser;
    }
    template <typename T> using sp = std::shared_ptr<T>;

}

%code
{
    // Our program is defined here
    sp<ast::Program> ourProgram;
    
    namespace yy
    {
        parser::symbol_type yylex();
        // no need to override the error function because it is already waiting for our implementation
    }
    void showExpr(const std::string& first, const std::string& op, const std::string& second)
    {
        std::cout<< first << op << second <<"\n";
        std::cout << "I am inside\n";
    }
    void dfs(sp<ast::Expression> exp)
    {
        if(exp == nullptr)
        {
            std::cout << "empty\n";
            return;
        }
        std::cout << "node is :";
        exp->print();
        std::cout << "\ngo left\n";
        dfs(exp->l);
        std::cout << "go right\n";
        dfs(exp->r);
        std::cout << "go back\n";
    }
}

/* declare tokens */
%token IDENTIFIER
%token INTEGER REAL
%token ADD SUB MUL DIV MOD
%token GRT GRTE LES LESE EQ NEQ
%token AND OR XOR
%token IF THEN ELSE
%token TRU FLS
%token VAR COL
%token TKEY
%token RUT
%token LBR RBR
%token COM
%token RTN IS
%token RNG IN REV
%token FOR WHL LOP
%token END
%token RCRD
%token ARY LAR RAR
%token DOTN
%token ASN
%token ITYPE RTYPE BTYPE
%token EOL
%token temp // TODO delete



%type<sp<ast::Type> > temp // TODO delete
%type<sp<ast::Type> > type
%type<sp<ast::BuiltinType> > PrimitiveType
%type<sp<ast::Array> > ArrayType
%type<sp<ast::Record> > RecordType
%type<sp<ast::Expression> > Expression
%type<sp<ast::Expression> > Primary
%type <std::string>  IDENTIFIER
%type <std::string> ModifiablePrimary RoutineCall
%type <double> REAL
%type <int> INTEGER
%type <bool> TRU FLS

%left OR
%left XOR
%left AND
%left EQ NEQ
%left GRT GRTE LES LESE
%left ADD SUB
%left MUL DIV MOD


%%
program:  /*{ourProgram = std::make_shared<ast::Program>(); std::cout << "made a program\n"; }*/
| program SimpleDeclaration {/* TODO maybe use this to add the variables to our vars*/ }
| program RoutineDeclaration {/* TODO use this to add the pointers to our routines*/}
| program EOL
;

SimpleDeclaration: VariableDeclaration
| TypeDeclaration
;

VariableDeclaration: VAR IDENTIFIER COL type { std::cout << "defined variable " << $2 << " with type " << ($4)->name << "\n"; }
| VAR IDENTIFIER IS Expression {std::cout << $2 << " " << ($4)->name << std::endl; dfs($4);}
| VAR IDENTIFIER COL type IS Expression {std::cout << $2 << " " << ($6)->name << "\n"; dfs($6);}
;

TypeDeclaration: TKEY IDENTIFIER IS type { std::cout << "defined new type " << $2 << "\n"; }
;

RoutineDeclaration: RUT IDENTIFIER LBR Parameters RBR IS Body END { std::cout << "routine " << $2 << " was declared\n"; }
| RUT IDENTIFIER LBR Parameters RBR COL type IS Body END {  std::cout << "routine " << $2 << " was declared\n";  }
;

Parameters: ParameterDeclaration
| Parameters COM ParameterDeclaration
;

ParameterDeclaration: IDENTIFIER COL type
;

type:
| PrimitiveType {$$ = $1; /* casting from derived to base !!*/}
| ArrayType {$$ = $1; /* casting from derived to base !!*/}
| RecordType {$$ = $1; /* casting from derived to base !!*/}
;

PrimitiveType: ITYPE { $$ = std::make_shared<ast::BuiltinType>("integer");}
| RTYPE {              $$ =  std::make_shared<ast::BuiltinType> ("real"); }
| BTYPE {              $$ =  std::make_shared<ast::BuiltinType> ("boolean"); }
;

RecordType: RCRD VariableDeclarationBlock END {  $$ =  std::make_shared<ast::Record>("Record"); }
;

ArrayType: ARY LAR Expression RAR type { $$ = std::make_shared<ast::Array>("Array");}
| ARY LAR RAR type {                     $$ = std::make_shared<ast::Array>("Array");}
;

Body:
| Body SimpleDeclaration
| Body Statement
| Body EOL
;

Statement: Assignment
| RoutineCall
| WhileLoop
| ForLoop
| IfStatement
| Returntatement {std::cout << "return\n";}
;

Returntatement: RTN EOL
| RTN Expression
;

Assignment: ModifiablePrimary ASN Expression
;

RoutineCall: IDENTIFIER LBR Arguments RBR { std::cout << "routine " << $1 << " was called\n"; }
;

WhileLoop: WHL Expression LOP Body END { std::cout << "while loop\n"; }
;

ForLoop: FOR IDENTIFIER Range LOP Body END { std::cout << "for loop\n"; }
;

Range: IN Expression RNG Expression
| IN REV Expression RNG Expression
;

IfStatement: IF Expression THEN Body END
| IF Expression THEN Body EOL ELSE Body END
;

VariableDeclarationBlock:
| VariableDeclarationBlock VariableDeclaration
| VariableDeclarationBlock EOL
;

Expression: Primary { $$ = $1; } 
| Expression ADD Expression {           $$ = std::make_shared<ast::Expression>("+", $1, $3); }
| Expression SUB Expression  {          $$ = std::make_shared<ast::Expression>("-", $1, $3); }
| Expression DIV Expression {           $$ = std::make_shared<ast::Expression>("/", $1, $3); }
| Expression MUL Expression {           $$ = std::make_shared<ast::Expression>("*", $1, $3); }
| Expression MOD Expression {           $$ = std::make_shared<ast::Expression>("%", $1, $3); }
| Expression GRT Expression {           $$ = std::make_shared<ast::Expression>(">", $1, $3); }
| Expression GRTE Expression {          $$ = std::make_shared<ast::Expression>(">=", $1, $3); }
| Expression LES Expression {           $$ = std::make_shared<ast::Expression>("<", $1, $3); }
| Expression LESE Expression {          $$ = std::make_shared<ast::Expression>("<=", $1, $3); }
| Expression EQ Expression {            $$ = std::make_shared<ast::Expression>("=", $1, $3); }
| Expression NEQ Expression {           $$ = std::make_shared<ast::Expression>("/=", $1, $3); }
| Expression AND Expression {           $$ = std::make_shared<ast::Expression>("and", $1, $3); }
| Expression OR Expression {            $$ = std::make_shared<ast::Expression>("or", $1, $3); }
| Expression XOR Expression {           $$ = std::make_shared<ast::Expression>("xor", $1, $3); }
| SUB Expression { sp<ast::Expression> temp = std::make_shared<ast::Expression>(-1); $$ = std::make_shared<ast::Expression>("*", temp, $2); }
| LBR Expression RBR { $$ = $2; std::cout  << "braces around " << $$ << "\n"; }
;

Arguments: Expression
| Arguments COM Expression
;

Primary: INTEGER {                      $$ = std::make_shared<ast::Expression>($1); }
| REAL {                                $$ = std::make_shared<ast::Expression>($1); }
| TRU {                                 $$ = std::make_shared<ast::Expression>($1); }
| FLS {                                 $$ = std::make_shared<ast::Expression>($1); }
| ModifiablePrimary{ /*TODO change */   $$ = std::make_shared<ast::Expression>("ModifiablePrimary"); }
| RoutineCall {      /*TODO change */   $$ = std::make_shared<ast::Expression>("RoutineCall"); }
;

VariableAcess:
| VariableAcess DOTN IDENTIFIER
| VariableAcess LAR Expression RAR
;

ModifiablePrimary: IDENTIFIER VariableAcess
;
%%
namespace yy
{
    //overriding yylex in main.cpp

    void parser::error(const std::string& msg)
    {
        std::cout<<"syntax error!\n";
    }
}