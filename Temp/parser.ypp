
%require "3.2"
%define api.pure full

%{
    #include "AST.h"
%}
%code{
#include <stdio.h>
#include <string.h>
#include "Scanner.h"

// sp<T> = smart pointer of type T
sp<AST::Program> program = std::make_shared<AST::Program>();
//std::vector<sp<AST::Block>>();
}



%code{
    int yylex(YYSTYPE *lvalp);
    #include<iostream>
    #include<string>
    Scanner scanner;
    void yyerror(const char *error);
}


%union {
int n;
double d;
char s[1000];
sp<AST>
}


/* declare tokens */
%token IDENTIFIER
%token INTEGER REAL
%token ADD SUB MUL DIV MOD
%token GRT GRTE LES LESE EQ NEQ
%token AND OR XOR
%token IF THEN ELSE
%token TRU FLS
%token VAR COL
%token TKEY
%token RUT
%token LBR RBR
%token COM
%token RTN IS
%token RNG IN REV
%token FOR WHL LOP
%token END
%token RCRD
%token ARY LAR RAR
%token DOTN
%token ASN
%token ITYPE RTYPE BTYPE
%token EOL



%type <s> type PrimitiveType IDENTIFIER RecordType ArrayType
%type <s> Expression Primary INTEGER REAL TRU FLS ModifiablePrimary RoutineCall
%left OR
%left XOR
%left AND
%left EQ NEQ
%left GRT GRTE LES LESE
%left ADD SUB
%left MUL DIV MOD


%%
program:
| program EOL
| program SimpleDeclaration {}
| program RoutineDeclaration { }
;

SimpleDeclaration: VariableDeclaration
| TypeDeclaration
;

VariableDeclaration: VAR IDENTIFIER COL type{
     printf("defined variable \"%s\" with type %s\n", $2, $4);
        sp<AST::Variable> v = std::make_shared<AST::Variable>($2);
        program->variables.push_back(v);
        std::cout << "pushed to the vector\n";
      }
| VAR IDENTIFIER IS Expression 
{sp<AST::Variable> v = std::make_shared<AST::Variable>($2);
        program->variables.push_back(v);}
| VAR IDENTIFIER COL type IS Expression{
    sp<AST::Variable> v = std::make_shared<AST::Variable>($2);
        program->variables.push_back(v);
}
;

TypeDeclaration: TKEY IDENTIFIER IS type { printf("defined new type %s \n", $2); }
;

RoutineDeclaration: RUT IDENTIFIER LBR Parameters RBR IS Body END { printf("routine %s was declared\n", $2); }
| RUT IDENTIFIER LBR Parameters RBR COL type IS Body END { printf("routine %s was declared\n", $2); }
;

Parameters: ParameterDeclaration
| Parameters COM ParameterDeclaration
;

ParameterDeclaration: IDENTIFIER COL type
;

type: IDENTIFIER
| PrimitiveType
| ArrayType
| RecordType
;

PrimitiveType: ITYPE { strcpy($$, "int"); }
| RTYPE { strcpy($$, "real"); }
| BTYPE { strcpy($$, "bool"); }
;

RecordType: RCRD VariableDeclarationBlock END {  strcpy($$, "record"); printf("record was defined\n"); }
;

ArrayType: ARY LAR Expression RAR type {  strcpy($$, "array"); printf("array was defined\n"); }
| ARY LAR RAR type {  strcpy($$, "array"); printf("array was defined\n"); }
;

Body:
| Body SimpleDeclaration { sp<AST::Block> temp = std::make_shared<AST::Block>();}
| Body Statement { sp<AST::Block> temp = std::make_shared<AST::Block>();}
| Body EOL { sp<AST::Block> temp = std::make_shared<AST::Block>();}
;

Statement: Assignment
| RoutineCall
| WhileLoop 
| ForLoop 
| IfStatement
| Returntatement { printf("return\n"); }
;

Returntatement: RTN EOL
| RTN Expression
;

Assignment: ModifiablePrimary ASN Expression
;

RoutineCall: IDENTIFIER LBR Arguments RBR { printf("routine %s was called\n", $1); }
;

WhileLoop: WHL Expression LOP Body END
{
    sp<AST::WhileLoop> whileLoop = std::make_shared<AST::WhileLoop>();
     printf("while loop\n"); 
}
;

ForLoop: FOR IDENTIFIER Range LOP Body END 
{
    sp<AST::ForLoop> forLoop = std::make_shared<AST::ForLoop>();
    printf("for loop\n"); 
}
;

Range: IN Expression RNG Expression
| IN REV Expression RNG Expression
;

IfStatement: IF Expression THEN Body END
{
    sp<AST::IfStatement> ifStatement = std::make_shared<AST::IfStatement>();
}
| IF Expression THEN Body EOL ELSE Body END
{
    sp<AST::IfStatement> ifStatement = std::make_shared<AST::IfStatement>();
}
;

VariableDeclarationBlock:
| VariableDeclarationBlock VariableDeclaration
| VariableDeclarationBlock EOL
;

Expression: Expression ADD Expression {sprintf($$, "[%s+%s]", $1, $3); printf("%s+%s\n", $1, $3); sp<AST::Expression> temp = std::make_shared<AST::Expression>($1,$3,'+');}
| Expression SUB Expression  { sprintf($$, "[%s-%s]", $1, $3); printf("%s-%s\n", $1, $3); sp<AST::Expression> temp = std::make_shared<AST::Expression>($1,$3,'-');}
| Expression DIV Expression { sprintf($$, "[%s/%s]", $1, $3); printf("%s/%s\n", $1, $3); sp<AST::Expression> temp = std::make_shared<AST::Expression>($1,$3,'/');}
| Expression MUL Expression { sprintf($$, "[%s*%s]", $1, $3); printf("%s*%s\n", $1, $3); sp<AST::Expression> temp = std::make_shared<AST::Expression>($1,$3,'*');}
| Expression MOD Expression { sprintf($$, "[%s%%%s]", $1, $3); printf("%s%%%s\n", $1, $3); sp<AST::Expression> temp = std::make_shared<AST::Expression>($1,$3,'%');}
| Expression GRT Expression { sprintf($$, "[%s>%s]", $1, $3); printf("%s>%s\n", $1, $3); sp<AST::Expression> temp = std::make_shared<AST::Expression>($1,$3,'>');}
| Expression GRTE Expression { sprintf($$, "[%s>=%s]", $1, $3); printf("%s>=%s\n", $1, $3); sp<AST::Expression> temp = std::make_shared<AST::Expression>($1,$3,">=");}
| Expression LES Expression { sprintf($$, "[%s<%s]", $1, $3); printf("%s<%s\n", $1, $3); sp<AST::Expression> temp = std::make_shared<AST::Expression>($1,$3,'<');}
| Expression LESE Expression { sprintf($$, "[%s<=%s]", $1, $3); printf("%s<=>%s\n", $1, $3); sp<AST::Expression> temp = std::make_shared<AST::Expression>($1,$3,"<=");}
| Expression EQ Expression { sprintf($$, "[%s=%s]", $1, $3); printf("%s=%s\n", $1, $3); sp<AST::Expression> temp = std::make_shared<AST::Expression>($1,$3,'=');}
| Expression NEQ Expression { sprintf($$, "[%s/=%s]", $1, $3); printf("%s/=%s\n", $1, $3); sp<AST::Expression> temp = std::make_shared<AST::Expression>($1,$3,"/=");}
| Expression AND Expression { sprintf($$, "[%s and %s]", $1, $3); printf("%s and %s\n", $1, $3); sp<AST::Expression> temp = std::make_shared<AST::Expression>($1,$3,"and");}
| Expression OR Expression { sprintf($$, "[%s or %s]", $1, $3); printf("%s or %s\n", $1, $3); sp<AST::Expression> temp = std::make_shared<AST::Expression>($1,$3,"or");}
| Expression XOR Expression { sprintf($$, "[%s xor %s]", $1, $3);  printf("%s xor %s\n", $1, $3); sp<AST::Expression> temp = std::make_shared<AST::Expression>($1,$3,"xor");}
| SUB Expression { strcpy($$, $2);  printf("unary minus\n");}
| Primary {  }
| LBR Expression RBR { strcpy($$, $2); printf("braces around %s\n", $2); }
;

Arguments: Expression
| Arguments COM Expression
;

Primary: INTEGER { strcpy($$, "integer"); }
| REAL { strcpy($$, "real"); }
| TRU { strcpy($$, "true"); }
| FLS { strcpy($$, "false"); }
| ModifiablePrimary { strcpy($$, "modifiablePrimary"); }
| RoutineCall { strcpy($$, "routineCall"); }
;

VariableAcess:
| VariableAcess DOTN IDENTIFIER
| VariableAcess LAR Expression RAR
;

ModifiablePrimary: IDENTIFIER VariableAcess
;
%%
int main()
{
    scanner.set_file("inp.txt");
    return yyparse();
}

void yyerror(const char *error)
{
    std::cout << "syntax error" << std::endl;
}

int yylex(YYSTYPE *lvalp)
{
	return scanner.get_next_token(lvalp);
}