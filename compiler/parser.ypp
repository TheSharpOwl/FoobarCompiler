
%require "3.2"
%define api.pure full


%code{
#include <stdio.h>
#include <string.h>
#include "Scanner.h"
#include "ast.h"
}



%code{
    int yylex(YYSTYPE *lvalp);
    #include<iostream>
    #include<string>
    Scanner scanner;
    void yyerror(const char *error);
}


%union {
    struct ast *a;
    int n;
    string name;
    double d;
}


/* declare tokens */
%token IDENTIFIER
%token INTEGER REAL
%token ADD SUB MUL DIV MOD
%token GRT GRTE LES LESE EQ NEQ
%token AND OR XOR
%token IF THEN ELSE
%token TRU FLS
%token VAR COL
%token TKEY
%token RUT
%token LBR RBR
%token COM
%token RTN IS
%token RNG IN REV
%token FOR WHL LOP
%token END
%token RCRD
%token ARY LAR RAR
%token DOTN
%token ASN
%token ITYPE RTYPE BTYPE
%token EOL



%type <d> REAL
%type <n> INTEGER

%left OR
%left XOR
%left AND
%left EQ NEQ
%left GRT GRTE LES LESE
%left ADD SUB
%left MUL DIV MOD


%%

program: { $$ = make_ast_list(); }
| program EOL
| program SimpleDeclaration { add_ast($1, $2); }
| program RoutineDeclaration { add_ast($1, $2); }
;

SimpleDeclaration: VariableDeclaration
| TypeDeclaration
;

VariableDeclaration: VAR IDENTIFIER COL type { $$ = new_var($2, $4, NULL); }
| VAR IDENTIFIER IS Expression { $$ = new_var($2, NULL, $4) }
| VAR IDENTIFIER COL type IS Expression { $$ = new_var($2, $4, $6) }
;

TypeDeclaration: TKEY IDENTIFIER IS type {  $$ = new_type($2, $4); }
;

RoutineDeclaration: RUT IDENTIFIER LBR Parameters RBR IS Body END { $$ = new_routine($2, $4, NULL, $7); }
| RUT IDENTIFIER LBR Parameters RBR COL type IS Body END { $$ = new_routine($2, $4, $7, $9); }
;

Parameters: ParameterDeclaration { $$ = new_args(); }
| Parameters COM ParameterDeclaration { add_args($1, $3); }
;

ParameterDeclaration: IDENTIFIER COL type { $$ = newp($1, $3); }
;

type: IDENTIFIER
| PrimitiveType
| ArrayType
| RecordType
;

PrimitiveType: ITYPE { $$ =  $1; }
| RTYPE { $$ =  $1; }
| BTYPE { $$ =  $1; }
;

RecordType: RCRD VariableDeclarationBlock END {  }
;

ArrayType: ARY LAR Expression RAR type { $$ = newarr($3, $5); }
| ARY LAR RAR type { $$ = newarr(NULL, $4); }
;

Body: { $$ = make_ast_list(); }
| Body SimpleDeclaration { add_ast($1, $2); }
| Body Statement { add_ast($1, $2); }
| Body EOL
;

Statement: Assignment
| RoutineCall
| WhileLoop
| ForLoop
| IfStatement
| Returntatement
;

Returntatement: RTN EOL { $$ = NULL; }
| RTN Expression { $$ = $2; }
;

Assignment: ModifiablePrimary ASN Expression { $$ = newasgn($1, $3); }
;

RoutineCall: IDENTIFIER LBR Arguments RBR { $$ = newcall($1, $3); }
;

WhileLoop: WHL Expression LOP Body END { $$ = newflow('W', $2, $4, NULL); }
;


ForLoop: FOR IDENTIFIER Range LOP Body END { $$ = forloop($2, $3, $5); }
;

Range: IN Expression RNG Expression { $$ = range(false, $2, $4); }
| IN REV Expression RNG Expression { $$ = range(true, $2, $4); }
;

IfStatement: IF Expression THEN Body END { $$ = newflow('I', $2, $4, NULL); }
| IF Expression THEN Body EOL ELSE Body END { $$ = newflow('I', $2, $4, $6); }
;

VariableDeclarationBlock: { $$ = make_ast_list(); }
| VariableDeclarationBlock VariableDeclaration { add_ast($1, $2);  }
| VariableDeclarationBlock EOL
;

Expression: Expression ADD Expression { $$ = newast(NodeType::ADD, $1,$3); }
| Expression SUB Expression { $$ = newast(NodeType::SUB, $1,$3); }
| Expression DIV Expression { $$ = newast(NodeType::DIV, $1,$3); }
| Expression MUL Expression { $$ = newast(NodeType::MULT, $1,$3); }
| Expression MOD Expression { $$ = newast(NodeType::MOD, $1,$3); }
| Expression GRT Expression { $$ = newast(NodeType::GRT, $1,$3); }
| Expression GRTE Expression { $$ = newast(NodeType::GRTE, $1,$3); }
| Expression LES Expression { $$ = newast(NodeType::LES, $1,$3); }
| Expression LESE Expression { $$ = newast(NodeType::LESE, $1,$3); }
| Expression EQ Expression { $$ = newast(NodeType::EQ, $1,$3); }
| Expression NEQ Expression { $$ = newast(NodeType::NEQ, $1,$3); }
| Expression AND Expression { $$ = newast(NodeType::AND, $1,$3); }
| Expression OR Expression { $$ = newast(NodeType::OR, $1,$3); }
| Expression XOR Expression { $$ = newast(NodeType::XOR, $1,$3); }
| SUB Expression { $$ = newast(NodeType::SUB, 0, $2); }
| Primary { }
| LBR Expression RBR { $$ = $2; }
;


Primary: INTEGER { $$ = newnum($1); }
| REAL {  $$ = newnum($1); }
| TRU { $$ = 1 }
| FLS { $$ = 0 }
| ModifiablePrimary
| RoutineCall
;

ModifiablePrimary: IDENTIFIER VariableAcess { $$ = newref($1); }
;

VariableAcess:
| VariableAcess DOTN IDENTIFIER { $$ = newac($1); }
| VariableAcess LAR Expression RAR { $$ = newac($1); }
;

%%
int main()
{
    scanner.set_file("inp.txt");
    return yyparse();
}

void yyerror(const char *error)
{
    std::cout << "syntax error" << std::endl;
}

int yylex(YYSTYPE *lvalp)
{
	return scanner.get_next_token(lvalp);
}